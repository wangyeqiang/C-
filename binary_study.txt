						 运算符优先级与求值次序

	单目运算	双目运算	位左右移	关系	位运算	逻辑	运算赋值	位运算赋值
1	～	*	<<	<	&	&&	=	&=
2	！	/	>>	<=	^	||	+=	^=
3	++	%		>	|		-=	|=
4	--	+		>=			*=	<<=
5	+	-		==			/=	>>=
6	-			!=			%=
7	*
8	&
9	(type)
10	sizeof

关于补码学习的总结

	1. 首先补码的产生是为了解决计算机对减法的计算不够友好（并不是不能计算，而是比较复杂，要判断大小，正负）的这个问题。
	2. 补码的产生是根据“模”的原理，这个“模“就相当于三角函数的周期或者钟表的表盘。我们让6点到3点可以是6 - 3 = 3 （式2.1） 6+9=3（式2.2）。式2.2成立的原因是对15 mod 12运算后得到的，因此真实的2.2运算应该是(6+9) mod 12 = 3.这个“模”就是12。这里9就相当于-3,可以说是-3的补数。

	3. 也就是说两个在模M内的非负数a,b,计算机不会计算a-b,那么该怎么办？，我们可以得到a - b = a - b + M = a + (M-b), ***M-b就相当于b的补数，数字电路中计算补数是不用减法的***。
	4. 所以补数的这个问题可以解决减法的问题，使减法变成加法。
	5. 同样他也解决了负数的表示问题，是怎么解决的呢？我们继续看原来的这个式子a - b = a + (M - b)；这个式子可以看到右边一定为正，而左边不一定，我们假如a<b,a-b=c （c<0）那么右边就是M+c，没错就是c的补数。所以计算机就把负数用补数来表示了，运算起来也更方便。
	6. 可是怎么区分这个数是整数还是负数的补数呢，于是有了天才的想法就是取一个偶数模，一半为整数，一半为负数，尤其对于二进制特别适合，一个8位的二进制数：0000 0000 ～ 0111 1111 表示正数，1000 0000 ~ 1111 1111表示负数的补数，而恰好正数全是0开头，负数全是1开头，他们已经各自分好阵营。于是我们就可以完全把第一位当成符号位，0表示正数，1表示负数，也就是说后面的7位表示数值。这样就可以直接在存储的时候直接转换为补码并存储，那么怎么转换呢 ？

	-0011 0110【-52】(原码：1011 0110)取反是 1100 1001(其实这也就相当于1011 0110符号位不变，其余取反，也就是反码的取得方式，在这里我觉得反码就是这样诞生的，但是应该不对) ，而我们可以看到
	1011 0110（原码） + 1100 1001（反码） = 1111 1111
	而这1111 1111又恰好是“模”(1 0000 0000)【256】 - （0000 0001）【1】呀，
	所以 :负数（原码） + 反码表示的数(反码) = 模 - 1
	--> 反码表示的数(反码) + 1 = 模 - 负数（原码） = 补数（补码）
	 --> 补码 = 反码 + 0000 0001；
	这也就验证了补码就是负数的原码取反+1.

	7. 这里有一个特例就是1000 0000它为什么是-128，而不是-0？这里我看了好多也没找到合理的解释，我自己分析如下：前面提到模1 0000 00000（256）把他们二分，分成0000 0000 ～0111 1111 （0～127）， 1000 0000～1111 1111实际上是128～255的，但是我们视后面这些为补数，eg:1111 11111=255，按照前面的负数c的补数是256+c, 那么补数255（1111 1111）就是-1（1000 0001）的补数。那么128（10000 0000）【这里是补数】就是-128（1000 0000）【这里是负数】的补数，所以这里1000 0000的值为-128而不是-0也就顺利成章了。所以补码的第一位并不代表符号为，他就是真真正正的补数，就是模后一半的数，和正数一样，第一位也是有效数字，运算结果是完全正确。
	8. 所以最后正数和补数是用来存储和计算的，而负数的表示则是用来看的。



位运算总结   // 这里关于二进制的运算都是以补码的形式去运算的
	正数	负数
原码	0开头	1开头
反码	原码本身	符号位不变其余取反
补码	原码本身	反码+1

& 按位与   必须所在位都为1时，才为1，一般用来计算数的奇偶
0001 1011
0000 0001
0000 0001

^ 按为异或  必须所在位不同，才为1，一半用来加密字符串，因为对同一个值两次异或就是这个值本身。
0001 1000
1011 0110
1010 1110
1011 0110
0001 1000     # 经过两次位运算又变成了本身

| 按位或 所在位只有全为0时，才为0
0001 1001
0010 1100
0000 1000

～取反运算   // 对于数x最后取反的结果就是 ~ x = - (x+1)
正数按位取反。// 先得到补码 然后取反。然后再取补码
原码    0000  0001 // 1

补码    0000  0001
取反    1111  1110.

补码    1000  0010   // -2 这个就是展现给人类看到的


负数按位取反
原码  1000 0001   // -1

补码  1111 1111
取反  0000 0000

补码  0000 0000. // 0


移位运算算
左移 右移。在移位运算的时候，比int低的类型会自动转为int类型

移位运算包括
算术移位：移出去的位丢弃，空缺位用“符号位补齐”，所以一般用到右移运算中
逻辑移位：移出去的位丢弃，空缺位补0

所以对于无符号来说，左移和右移都是用的逻辑移位；
对于有符号来说，左移用逻辑移位，右移用算术移位。

 I = 2 , J =-2
 I<<2:   0000 0010.   //逻辑移位，直接在原码操作
	     0000 1000   = 8
 I >>2:  0000 0010    // 逻辑移位，直接在原码操作
             0000 0000 = 0
J << 2:  1000 0010    // 逻辑移位，直接在原码操作
              1000 1000 =  -8
J >>2:   1000 0010.    // 算术移位，需要在补码操作
              1111 1110    // 补码
              1111 1111。 // 移位
	      1000 0001 = -1。 //再补码


浮点数存储
根据国际标准IEEE 754,任意一个二进制浮点数可以表示成下面的形式:
		V = (-1)S  x M x 2E
（1）其中s代表符号位，1代表负，0代表正；
（2）M代表有效数字，大于1，小于2；
（3）2^E表示指数位；


两种二进制浮点数格式
浮点数类型	S	阶码E	尾数M	总长度
短实数	1	8	23	32
长实数	1	11	52	64
注意阶码表示正数但是并不是用补码表示，而是用移码；
阶码的移码表示格式如下：E = e + 偏移值，其中E是阶码的移码，e是阶码的真值，既作为整数的实际阶码值。偏移值是个固定的常数，如果表示阶码的二进制位数位w，那么偏移值=2w - 1.
尾数的表示形式为x1x2x3…xn,其真值是1.x1x2x3…xn。所以如果数符是S，阶码真值为e，尾数格式为x1x2x3…xn，则浮点数的表示形式为(-1)S X 2e X 1.x1x2x3…xn

那么求出-1270.9375的短实数表示
整数1270 = 10011110110
小数0.9375的二进制表示是0.x1x2x3…xn,则a1是对小数0.9375第一次乘2的到的整数，a2是第一次乘积的小数部分乘2后得到的整数，以此类推，直到乘积的小数部分为0，或是二进制小数位数达到要求的位数。因此，求出a1a2a3…an的计算过程如下：
			2 X 0.9375 = 1.875, a1 =1
			2 X 0.875 = 1.75, a2 =1
			2 X 0.75 = 1.5, a3=1
			2 X 0.5 = 1.0, a4 = 1
二进制小数部分只有4位，a1a2a3a4 = 1111。因此 - 1270.9375 = -10011110110.1111
将二进制浮点数转换成以下1.x1x2x3…xn X 2e 格式    // 这个人类的展现方式
      - 10011110110.1111 = -1.00111101101111 X 2 1010 //    这里的1010就是10小数点左移了10位
所以对于-1.00111101101111 X 2 1010，
数符S = 1
阶码移码 = 0111 1111 + 1010 = 10001001   //  0111 1111是移码，28 -1
尾数 = 0011 1101 1011 1100 0000 000      // 注：这里的尾数在是偶面补0，共23位，它包括原来的小数位和整数位
所以 // 下面的是计算的的表现方式
真值	数符	阶码	尾数
-1270.9375	1	10001001	0011110110111100000000

